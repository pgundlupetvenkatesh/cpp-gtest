        -:    0:Source:rando.cpp
        -:    0:Graph:rando.gcno
        -:    0:Data:rando.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "rando.h"
        -:    2:#include <stdlib.h>
        -:    3:#include <math.h>
        -:    4:#include <vector>
        -:    5:#include <algorithm>
        -:    6:
        -:    7:using namespace std;
        -:    8:
        -:    9:
        -:   10:/**
        -:   11: * Worry if only one child is smiling or if all children are smiling
        -:   12:**/
        3:   13:bool Rando::shouldWorry(bool childASmile, bool childBSmile, bool childCSmile)
        -:   14:{
        3:   15:	if( childASmile && childBSmile && childCSmile )
        1:   16:		return true;
        2:   17:	else if( childASmile ^ childBSmile ^ childCSmile )
        1:   18:		return true;
        -:   19:	else
        1:   20:		return false;
        -:   21:}
        -:   22:/**
        -:   23: * Determines if first or second are evenly divisible by the other.
        -:   24:**/
        8:   25:bool Rando::isDivisibleBy(int first, int second)
        -:   26:{
        8:   27:	if(first == 0 || second == 0) {
        -:   28:		//return false;
        2:   29:		throw -1;
        -:   30:	}	
        6:   31:	if(first % second == 0) {
        3:   32:		return true;
        -:   33:	} else {
        3:   34:		return false;
        -:   35:	}
        -:   36:}
        -:   37:
        -:   38:/**
        -:   39: * Given a number, num, says whether or not that number is prime
        -:   40: * (that is, only evenly divisible by itself and 1. For the sake
        -:   41: * of this function, do NOT consider 0 prime)
        -:   42:**/
        6:   43:bool Rando::isPrime(int num)
        -:   44:{	
        6:   45:	if(num <= 1) {
        2:   46:		return false;
        -:   47:	}	
        8:   48:	for (int i=2; i<num; i++)
        -:   49:	{
        6:   50:		if (num % i == 0)
        -:   51:		{
        2:   52:			return false;
        -:   53:		}
        -:   54:	}
        2:   55:	return true;
        -:   56:}
        -:   57:
        -:   58:/**
        -:   59: * Given two numbers, first and second, return the value of the one
        -:   60: * that is closest to zero without actually being zero.
        -:   61:**/
        3:   62:int Rando::nearestToZero(int a, int b)
        -:   63:{
        3:   64:	if(a == 0 || b == 0) {
        1:   65:		return 1;
        2:   66:	} else if(a == b) {
        1:   67:		return 1;
        -:   68:	} else {
        2:   69:		vector<int> vect;
        1:   70:		vect.push_back(a);
        1:   71:		vect.push_back(b);
        1:   72:		sort(vect.begin(), vect.end());
        1:   73:		return vect.front();
        -:   74:	}	
        -:   75:	return 0;
        -:   76:}
